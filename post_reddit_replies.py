#!/usr/bin/env python3
"""
Reddit Reply Poster - Plain Text Version

This script reads a structured plain text file (e.g., potential_replies.txt) generated by potential-replies.py, finds entries marked for posting (MARK_TO_POST is '[x]'), and posts the suggested reply to Reddit using PRAW. It uses the specified TARGET_PARENT_ID (or defaults to the post's ID), and after successful posting, updates the marker to '[p]'. Reddit API credentials are loaded from .env.

Features:
- Reads a plain text file with structured reply suggestions and action blocks.
- Finds entries marked for posting and posts replies to Reddit (to posts or comments).
- Uses PRAW for Reddit API interaction, with credentials loaded from .env.
- Updates the marker in the text file after successful posting.
- Supports configurable file locations and delays between posts.

Usage:
    python post_reddit_replies.py

Environment Variables (set in .env):
    REDDIT_CLIENT_ID       - Reddit API client ID.
    REDDIT_CLIENT_SECRET   - Reddit API client secret.
    REDDIT_USER_AGENT      - User-Agent string for Reddit API requests.
    REDDIT_USERNAME        - Reddit username.
    REDDIT_PASSWORD        - Reddit password.
    TEXT_DATA_FOLDER       - Base folder for saving output files (default: data).

Outputs:
    - Posts replies to Reddit for marked entries.
    - Updates the plain text file to mark posted replies.
"""

import praw
import re
import time
import os
import logging
from dotenv import load_dotenv
from pathlib import Path

# --- Configuration ---
TEXT_FILE_PATH_DEFAULT = "potential_replies.txt"
REPLY_POST_DELAY_SECONDS = 10
MAX_API_ATTEMPTS = 3
# --- End Configuration ---

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# --- load_reddit_credentials, initialize_praw, post_reply_to_reddit (largely same as before) ---
def load_reddit_credentials():
    """Loads Reddit API credentials from .env file."""
    load_dotenv()
    creds = {
        "client_id": os.getenv("REDDIT_CLIENT_ID"),
        "client_secret": os.getenv("REDDIT_CLIENT_SECRET"),
        "user_agent": os.getenv("REDDIT_USER_AGENT"),
        "username": os.getenv("REDDIT_USERNAME"),
        "password": os.getenv("REDDIT_PASSWORD"),
    }
    if not all(creds.values()):
        logger.critical("Missing Reddit API credentials in .env. Check REDDIT_CLIENT_ID, _SECRET, _USER_AGENT, _USERNAME, _PASSWORD.")
        return None
    logger.info("Reddit API credentials loaded.")
    return creds

def initialize_praw(credentials):
    """Initializes and returns a PRAW Reddit instance."""
    if not credentials: return None
    try:
        reddit = praw.Reddit(
            client_id=credentials["client_id"], client_secret=credentials["client_secret"],
            user_agent=credentials["user_agent"], username=credentials["username"],
            password=credentials["password"],
        )
        logger.info(f"PRAW instance created. Authenticating as: {reddit.user.me()}")
        if reddit.user.me() is None: logger.error("PRAW auth failed: reddit.user.me() is None."); return None
        logger.info("PRAW initialized and authenticated.")
        return reddit
    except Exception as e:
        logger.error(f"PRAW initialization/authentication error: {e}", exc_info=True)
        return None

def post_reply_to_reddit(reddit: praw.Reddit, parent_fullname_or_id: str, reply_text: str) -> praw.models.Comment | None:
    target_object = None
    logger.info(f"Attempting to resolve parent ID: {parent_fullname_or_id}")

    # Ensure it's a fullname for PRAW's direct methods if only ID is given
    if not parent_fullname_or_id.startswith(('t1_', 't3_')):
        logger.warning(f"Parent ID '{parent_fullname_or_id}' lacks t1_/t3_ prefix. Will attempt to infer type.")
        try: # Try as submission (post)
            target_object = reddit.submission(id=parent_fullname_or_id)
            _ = target_object.title # Force fetch
            logger.info(f"Interpreted '{parent_fullname_or_id}' as POST: {target_object.fullname}")
        except Exception:
            try: # Try as comment
                target_object = reddit.comment(id=parent_fullname_or_id)
                _ = target_object.body # Force fetch
                logger.info(f"Interpreted '{parent_fullname_or_id}' as COMMENT: {target_object.fullname}")
            except Exception as e_inner:
                logger.error(f"Could not resolve '{parent_fullname_or_id}' as post or comment: {e_inner}")
                return None

    elif parent_fullname_or_id.startswith("t3_"):
        try:
            target_object = reddit.submission(id=parent_fullname_or_id.split('_',1)[1])
            _ = target_object.title 
            logger.info(f"Target identified as POST: {target_object.fullname}")
        except Exception as e: logger.error(f"Failed to fetch submission '{parent_fullname_or_id}': {e}"); return None
    elif parent_fullname_or_id.startswith("t1_"):
        try:
            target_object = reddit.comment(id=parent_fullname_or_id.split('_',1)[1])
            _ = target_object.body
            logger.info(f"Target identified as COMMENT: {target_object.fullname}")
        except Exception as e: logger.error(f"Failed to fetch comment '{parent_fullname_or_id}': {e}"); return None
    else:
        logger.error(f"Invalid parent ID format: {parent_fullname_or_id}. Should be t3_... or t1_... or raw ID."); return None

    if not target_object: logger.error(f"Could not fetch target object for {parent_fullname_or_id}"); return None

    for attempt in range(MAX_API_ATTEMPTS):
        try:
            logger.info(f"Attempting to post reply (attempt {attempt + 1}/{MAX_API_ATTEMPTS}) to {target_object.fullname}:\n>>>\n{reply_text[:100]}...\n<<<")
            posted_comment = target_object.reply(reply_text)
            logger.info(f"SUCCESS: Reply posted! New comment ID: {posted_comment.id}, URL: https://www.reddit.com{posted_comment.permalink}")
            return posted_comment
        except praw.exceptions.APIException as e:
            logger.error(f"PRAW APIException (attempt {attempt + 1}) for {target_object.fullname}: {e}")
            if "RATELIMIT" in str(e).upper():
                match = re.search(r"try again in (\d+) (minutes|seconds)", str(e), re.IGNORECASE)
                if match:
                    wait_time = int(match.group(1)) * (60 if match.group(2).lower() == "minutes" else 1)
                    logger.warning(f"Rate limit. Waiting {wait_time}s.")
                    time.sleep(max(wait_time, 5)); continue
            if attempt < MAX_API_ATTEMPTS - 1: time.sleep(REPLY_POST_DELAY_SECONDS); continue
            return None
        except Exception as e:
            logger.error(f"Unexpected error (attempt {attempt+1}) posting to {target_object.fullname}: {e}", exc_info=True)
            return None # Do not retry unexpected errors
    return None

def parse_post_entry(entry_text: str) -> dict | None:
    """Parses a single post entry block from the text file."""
    data = {}
    
    # Extract key-value pairs like POST_ID_FULL, POST_URL, etc.
    # Make the value part non-greedy and ensure it stops at the end of the line
    # (.*?)$ will match any character non-greedily until the end of the line
    key_value_pattern = re.compile(
        r"^(POST_ID_FULL|POST_URL|POST_TITLE|POST_AUTHOR|POST_SUBREDDIT|POST_DATE|MARK_TO_POST|TARGET_PARENT_ID|LLM_SUGGESTED_REPLY.*?):\s*(.*?)$", 
        re.MULTILINE
    )
    for match in key_value_pattern.finditer(entry_text):
        key = match.group(1).strip()
        value = match.group(2).strip() # Value is now correctly captured up to EOL

        if key.startswith("LLM_SUGGESTED_REPLY"): 
            # This key includes "(via ModelName)", so store it to capture model info if needed
            data["LLM_MODEL_INFO_LINE"] = key 
        else:
            data[key] = value
            # Specifically for TARGET_PARENT_ID, if its value was captured as the next line's key, reset it.
            # This is a fallback, the (.*?)$ should mostly fix it.
            if key == "TARGET_PARENT_ID" and value.startswith("LLM_SUGGESTED_REPLY"):
                logger.debug(f"Correcting TARGET_PARENT_ID: was '{value}', now empty.")
                data[key] = ""

    # Extract multi-line blocks
    body_match = re.search(r"---POST_BODY_START---\n(.*?)\n---POST_BODY_END---", entry_text, re.DOTALL)
    if body_match: data["POST_BODY"] = body_match.group(1).strip()

    comments_match = re.search(r"---COMMENTS_START---\n(.*?)\n---COMMENTS_END---", entry_text, re.DOTALL)
    if comments_match: data["COMMENTS_TEXT"] = comments_match.group(1).strip()
    
    reply_match = re.search(r"---SUGGESTED_REPLY_START---\n(.*?)\n---SUGGESTED_REPLY_END---", entry_text, re.DOTALL)
    if reply_match: data["SUGGESTED_REPLY_TEXT"] = reply_match.group(1).strip()

    # Ensure essential fields for action are present
    if not all(k in data for k in ["MARK_TO_POST", "SUGGESTED_REPLY_TEXT"]):
        logger.warning(f"Skipping entry due to missing MARK_TO_POST or SUGGESTED_REPLY_TEXT. Snippet:\n{entry_text[:300]}...")
        return None
    # TARGET_PARENT_ID can be legitimately empty, so it's checked by the caller.
    # POST_ID_FULL is also checked by the caller as a fallback.
    return data

def process_text_file(reddit: praw.Reddit, txt_filepath: Path):
    """Processes the text file, finds marked replies, and posts them."""
    logger.info(f"Starting processing of text file: {txt_filepath}")
    if not txt_filepath.exists():
        logger.error(f"Text file not found: {txt_filepath}"); print(f"ERROR: File not found: {txt_filepath}"); return

    try:
        with open(txt_filepath, 'r', encoding='utf-8') as f:
            content = f.read()
    except IOError as e:
        logger.error(f"Could not read text file {txt_filepath}: {e}"); print(f"ERROR: Reading file: {e}"); return

    entry_blocks = re.findall(r"===START_POST_ENTRY===\n(.*?)\n===END_POST_ENTRY===", content, re.DOTALL)
    
    if not entry_blocks:
        logger.info("No post entries found in the text file (delimited by ===START/END_POST_ENTRY===).")
        print("No processable entries found in the file.")
        return

    processed_count = 0
    posted_count = 0
    modified_content = content # Start with original content to modify

    for i, entry_text_original in enumerate(entry_blocks):
        logger.info(f"\n--- Examining Entry {i+1}/{len(entry_blocks)} ---")
        entry_data = parse_post_entry(entry_text_original)

        if not entry_data:
            logger.warning(f"Failed to parse entry {i+1}. Skipping.")
            continue

        mark_to_post_value = entry_data.get("MARK_TO_POST", "").strip()
        
        if mark_to_post_value.lower() == "[x]":
            processed_count += 1
            logger.info(f"Found entry marked [x] for posting. Post Title: {entry_data.get('POST_TITLE', 'N/A')}")
            print(f"\nFound reply marked [x] for post: {entry_data.get('POST_URL', entry_data.get('POST_ID_FULL', 'Unknown Post'))}")

            reply_text_to_post = entry_data.get("SUGGESTED_REPLY_TEXT", "")
            if not reply_text_to_post or reply_text_to_post.lower().startswith("[llm failed"):
                logger.warning("Skipping due to empty or LLM-failed reply text.")
                print("Skipping: Reply text is empty or indicates LLM failure.")
                continue
            
            print(f"Suggested Reply:\n{reply_text_to_post}\n")

            target_parent_id_from_file = entry_data.get("TARGET_PARENT_ID", "").strip() 
            # This check is now more robustly handled by the (.*?)$ in parse_post_entry's regex,
            # but a direct check here adds another layer of safety if the regex had issues.
            if target_parent_id_from_file.startswith("LLM_SUGGESTED_REPLY"):
                logger.warning(f"Correcting potentially mis-parsed TARGET_PARENT_ID. Was: '{target_parent_id_from_file}', now empty.")
                target_parent_id_from_file = ""

            post_id_full_from_entry = entry_data.get("POST_ID_FULL", "").strip()

            final_target_id = ""
            if target_parent_id_from_file: 
                final_target_id = target_parent_id_from_file
                logger.info(f"User specified TARGET_PARENT_ID: {final_target_id}")
                print(f"Target specified by user: {final_target_id}")
            elif post_id_full_from_entry: 
                final_target_id = post_id_full_from_entry
                logger.info(f"TARGET_PARENT_ID is blank, defaulting to POST_ID_FULL from entry: {final_target_id}")
                print(f"Target (defaulting to post): {final_target_id}")
            else:
                logger.error("Cannot determine target: TARGET_PARENT_ID is blank and POST_ID_FULL is missing. Skipping.")
                print("ERROR: Cannot determine target for this reply. Skipping.")
                continue
            
            confirm_post = input(f"Confirm posting this reply to target '{final_target_id}'? (y/n): ").strip().lower()
            if confirm_post == 'y':
                posted_comment_obj = post_reply_to_reddit(reddit, final_target_id, reply_text_to_post)
                if posted_comment_obj:
                    posted_count += 1
                    
                    action_block_pattern_text = (
                        r"(---ACTION_BLOCK_START---\n)"
                        r"(MARK_TO_POST:\s*\[x\]\n)" 
                        r"(TARGET_PARENT_ID:.*?\n)"
                        r"(LLM_SUGGESTED_REPLY.*?\n)" # This should match the LLM_MODEL_INFO_LINE
                        r"(---SUGGESTED_REPLY_START---\n(?:.|\n)*?\n---SUGGESTED_REPLY_END---\n)"
                        r"(---ACTION_BLOCK_END---)"
                    )
                    action_block_pattern = re.compile(action_block_pattern_text, re.MULTILINE)
                    
                    match_action_block = action_block_pattern.search(entry_text_original)
                    if match_action_block:
                        new_action_block = (
                            match_action_block.group(1) + 
                            "MARK_TO_POST: [p]\n" +       
                            match_action_block.group(3) + 
                            match_action_block.group(4) + 
                            match_action_block.group(5) + 
                            match_action_block.group(6)   
                        )
                        temp_modified_entry = entry_text_original.replace(match_action_block.group(0), new_action_block, 1)
                        
                        if temp_modified_entry != entry_text_original:
                             modified_content = modified_content.replace(entry_text_original, temp_modified_entry, 1)
                             logger.info(f"Marker updated to '[p]' for entry related to {final_target_id}.")
                        else:
                             logger.warning(f"Could not update marker (structural replace failed) for {final_target_id}.")
                    else:
                        logger.warning(f"Could not find the exact action block structure to update marker for {final_target_id}. Original MARK_TO_POST value was: {mark_to_post_value}")

                else:
                    logger.error(f"Failed to post reply for target {final_target_id}.")
                    print(f"Failed to post reply for {final_target_id}.")
                
                logger.info(f"Waiting {REPLY_POST_DELAY_SECONDS} seconds before next action...")
                time.sleep(REPLY_POST_DELAY_SECONDS)
            else:
                logger.info("User chose not to post this reply. Skipping.")
                print("Skipping this reply.")
        else:
            logger.debug(f"Entry {i+1} not marked with [x] (MARK_TO_POST: '{mark_to_post_value}'). Skipping.")

    if processed_count == 0:
        logger.info("No replies marked with '[x]' found and processed in the text file.")
        print("No replies marked with '[x]' were processed.")
    else:
        logger.info(f"Processed {processed_count} entries marked with '[x]'. Posted {posted_count} replies.")
        print(f"\nProcessed {processed_count} entries marked '[x]'. Posted {posted_count} replies.")

    if content != modified_content:
        try:
            with open(txt_filepath, 'w', encoding='utf-8') as f:
                f.write(modified_content)
            logger.info(f"Text file '{txt_filepath}' updated with '[p]' markers.")
            print(f"Text file '{txt_filepath}' updated.")
        except IOError as e:
            logger.error(f"Failed to write updates to text file '{txt_filepath}': {e}")
            print(f"ERROR: Failed to write updates to text file '{txt_filepath}'.")
    else:
        logger.info("No modifications made to the text file content (no successful posts or markers already updated).")

def main():
    """Main function to drive the script."""
    logger.info("--- Reddit Reply Poster Script (Plain Text Version) Starting ---")
    print("--- Reddit Reply Poster (Plain Text Version) ---")

    data_dir_path = Path("data") / TEXT_FILE_PATH_DEFAULT
    current_dir_path = Path(TEXT_FILE_PATH_DEFAULT)

    if data_dir_path.exists():
        txt_file_to_process = data_dir_path
    elif current_dir_path.exists():
        txt_file_to_process = current_dir_path
    else:
        # Try checking TEXT_DATA_FOLDER from .env, as suggester uses it
        env_text_data_folder = os.getenv("TEXT_DATA_FOLDER", "data") # Default to "data" if not set
        env_path = Path(env_text_data_folder) / TEXT_FILE_PATH_DEFAULT
        if env_path.exists():
            txt_file_to_process = env_path
        else:
            logger.error(f"Text file '{TEXT_FILE_PATH_DEFAULT}' not found in ./data/, current directory, or TEXT_DATA_FOLDER ('{env_text_data_folder}').")
            print(f"ERROR: Text file '{TEXT_FILE_PATH_DEFAULT}' not found.")
            return
    
    logger.info(f"Using text file: {txt_file_to_process.resolve()}")

    reddit_creds = load_reddit_credentials()
    if not reddit_creds: print("Failed to load Reddit credentials. Exiting."); return

    reddit_instance = initialize_praw(reddit_creds)
    if not reddit_instance: print("Failed to initialize PRAW. Exiting."); return

    process_text_file(reddit_instance, txt_file_to_process)

    logger.info("--- Reddit Reply Poster Script (Plain Text Version) Finished ---")
    print("--- Script Finished ---")

if __name__ == "__main__":
    main()
